---
import BaseLayout from "../components/layouts/BaseLayout.astro";
import Document from "../components/sections/Document.astro";
import HeroOrbit from "../components/sections/HeroOrbit.astro";
import { getCollection } from "astro:content";

const title = "Design System";
const docs = await getCollection("documentation");
const sortedDocs = docs.sort((a, b) => a.id.localeCompare(b.id));

const renderedDocs = await Promise.all(
    sortedDocs.map(async (doc) => {
        const { Content } = await doc.render();
        const metadata = {
            Title: doc.data.title,
            Author: doc.data.author,
            Date: doc.data.date.toLocaleDateString("en-US", {
                year: "numeric",
                month: "long",
                day: "2-digit",
            }),
            Link: `#${doc.slug}`,
            Tags: doc.data.tags.join(", "),
        };
        return { doc, Content, metadata };
    }),
);
---

<BaseLayout title={title} bodyClass="design-system-page">
    <nav class="anchor-menu exposed-grid">
        <a href="#hero" class="nav-link small">~</a>
        {
            sortedDocs.map((doc, index) => (
                <a
                    href={`#${doc.slug}`}
                    class={index === 0 ? "nav-link" : "nav-link small"}
                >
                    {doc.data.title}
                </a>
            ))
        }
    </nav>
    <div class="main exposed-grid">
        <HeroOrbit id="hero" class="glitch-parent">
            <h1 class="h1 text-glitch" title={title}>{title}</h1>
        </HeroOrbit>
        {
            renderedDocs.map(({ doc, Content, metadata }) => (
                <Document id={doc.slug} metadata={metadata}>
                    <Content />
                </Document>
            ))
        }
    </div>
</BaseLayout>


<script>
    import "@maxhill/components/m-card";
    import "@maxhill/components/vendored/tab-container-element";

    const parent = document.querySelector(".main");
    if (!parent) throw new Error("Parent element .main not found");

    const children = document.querySelectorAll(".document, .hero");
    if (children.length === 0)
        throw new Error("No document or hero elements found");

    const navLinks = document.querySelectorAll(".nav-link");

    navLinks.forEach((link) => {
        link.addEventListener("click", (e) => {
            e.preventDefault();
            const href = link.getAttribute("href");
            if (!href) return;

            const targetId = href.substring(1);
            const targetElement = document.getElementById(targetId);
            if (!targetElement) return;

            targetElement.scrollIntoView({
                behavior: "smooth",
                inline: "end",
                block: "nearest",
            });
        });
    });

    children.forEach((child) => {
        child.addEventListener("click", () => {
            child.scrollIntoView({
                behavior: "smooth",
                inline: "end",
                block: "nearest",
            });
        });
    });

    const observerOptions = {
        root: parent,
        rootMargin: "0px",
        threshold: [0.5, 0.75, 0.99, 1.0],
    };

    const observer = new IntersectionObserver((_entries) => {
        const fullyVisibleElements = Array.from(children)
            .map((child) => {
                const rect = child.getBoundingClientRect();
                const rootRect = parent.getBoundingClientRect();
                const visibleWidth =
                    Math.min(rect.right, rootRect.right) -
                    Math.max(rect.left, rootRect.left);
                const ratio = visibleWidth / rect.width;
                return { element: child, ratio };
            })
            .filter(({ ratio }) => ratio >= 0.99);

        if (fullyVisibleElements.length === 0) return;

        children.forEach((child) => child.classList.remove("visible"));
        fullyVisibleElements.forEach(({ element }) => {
            element.classList.add("visible");
        });

        const rightmostElement =
            fullyVisibleElements[fullyVisibleElements.length - 1].element;

        children.forEach((child) => child.classList.remove("active"));
        navLinks.forEach((link) => link.classList.remove("active"));

        rightmostElement.classList.add("active");
        const targetId = rightmostElement.id;
        if (!targetId) return;

        const correspondingLink = document.querySelector(
            `a[href="#${targetId}"]`,
        );
        if (correspondingLink) {
            correspondingLink.classList.add("active");
        }

        history.replaceState(null, "", `#${targetId}`);
    }, observerOptions);

    children.forEach((child) => observer.observe(child));

    document.addEventListener("keydown", (e) => {
        if (!e.target) return;

        if (
            e.target instanceof HTMLInputElement ||
            e.target instanceof HTMLTextAreaElement
        ) {
            return;
        }

        const activeDocument = document.querySelector(".document.active");

        if (e.key === "ArrowDown" || e.key === "j") {
            e.preventDefault();
            if (activeDocument) {
                activeDocument.scrollBy({
                    top: 30,
                    behavior: "instant",
                });
            }
        } else if (e.key === "ArrowUp" || e.key === "k") {
            e.preventDefault();
            if (activeDocument) {
                activeDocument.scrollBy({
                    top: -30,
                    behavior: "instant",
                });
            }
        }

        const currentHash = window.location.hash.substring(1);
        const currentElement = currentHash
            ? document.getElementById(currentHash)
            : null;

        if (!currentElement) return;

        const childrenArray = Array.from(children);
        const currentIndex = childrenArray.indexOf(currentElement);
        if (currentIndex === -1) return;

        if ((e.key === "ArrowLeft" || e.key === "h") && currentIndex > 0) {
            e.preventDefault();
            const targetElement = childrenArray[currentIndex - 1];
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: "smooth",
                    inline: "end",
                    block: "nearest",
                });
            }
        } else if (
            (e.key === "ArrowRight" || e.key === "l") &&
            currentIndex < childrenArray.length - 1
        ) {
            e.preventDefault();
            const targetElement = childrenArray[currentIndex + 1];
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: "smooth",
                    inline: "end",
                    block: "nearest",
                });
            }
        }
    });
</script>
